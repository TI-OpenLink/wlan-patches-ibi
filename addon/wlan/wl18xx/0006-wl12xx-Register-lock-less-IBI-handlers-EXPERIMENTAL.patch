From 494e6abfb5d45266af5506c22ef8d8c034ab10f8 Mon Sep 17 00:00:00 2001
From: Ido Reis <idor@ti.com>
Date: Wed, 7 Nov 2012 11:49:22 +0200
Subject: [PATCH 06/12] wl12xx: Register lock-less IBI handlers *EXPERIMENTAL*

wl->mutex is normally acquired before claiming the mmc host. In the case
of IBI, the handler is called with the host already claimed. This means
that acquiring the mutex in the handler will result in an incorrect
locking order, which could lead to a deadlock.

Fix this by registering the handler as a lock-less one, and claim the
host after acquiring the mutex.

Signed-off-by: Ido Yariv <ido@wizery.com>
Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 drivers/net/wireless/ti/wlcore/main.c   |    4 +++-
 drivers/net/wireless/ti/wlcore/sdio.c   |   30 +++++++++++++++++++++++++++---
 drivers/net/wireless/ti/wlcore/wlcore.h |    1 +
 3 files changed, 31 insertions(+), 4 deletions(-)

diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index 2508ea1..cc10ef4 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -522,7 +522,7 @@ static void wl1271_netstack_work(struct work_struct *work)
 
 #define WL1271_IRQ_MAX_LOOPS 256
 
-static int wlcore_irq_locked(struct wl1271 *wl)
+int wlcore_irq_locked(struct wl1271 *wl)
 {
 	int ret = 0;
 	u32 intr;
@@ -650,6 +650,7 @@ static int wlcore_irq_locked(struct wl1271 *wl)
 out:
 	return ret;
 }
+EXPORT_SYMBOL(wlcore_irq_locked);
 
 irqreturn_t wlcore_irq(int irq, void *cookie)
 {
@@ -819,6 +820,7 @@ void wl12xx_queue_recovery_work(struct wl1271 *wl)
 		ieee80211_queue_work(wl->hw, &wl->recovery_work);
 	}
 }
+EXPORT_SYMBOL(wl12xx_queue_recovery_work);
 
 size_t wl12xx_copy_fwlog(struct wl1271 *wl, u8 *memblock, size_t maxlen)
 {
diff --git a/drivers/net/wireless/ti/wlcore/sdio.c b/drivers/net/wireless/ti/wlcore/sdio.c
index ef3deb4..d27bbe1 100644
--- a/drivers/net/wireless/ti/wlcore/sdio.c
+++ b/drivers/net/wireless/ti/wlcore/sdio.c
@@ -219,6 +219,10 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 
 	dev_dbg(&func->dev, "SDIO IRQ");
 
+	/* TX might be handled here, avoid redundant work */
+	set_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
+	cancel_work_sync(&wl->tx_work);
+
 	if (WARN_ON(!glue->handler || !glue->thread_fn))
 		return;
 
@@ -227,10 +231,30 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 
 	ret = glue->handler(0, glue->irq_cookie);
 	if (ret == IRQ_WAKE_THREAD) {
+
+		mutex_lock(&wl->mutex);
+		if (sdio_claim_host_irq(func)) {
+			/*
+			 * Theoretically we need to reschedule TX work.
+			 * Practically, if the irq is freed, there's little
+			 * point in doing so.
+			 */
+			mutex_unlock(&wl->mutex);
+			return;
+		}
+
+		ret = wlcore_irq_locked(wl);
+		if (ret)
+			wl12xx_queue_recovery_work(wl);
+
 		sdio_release_host(func);
-		glue->thread_fn(0, glue->irq_cookie);
-		sdio_claim_host(func);
+		mutex_unlock(&wl->mutex);
 	}
+	/*
+	 * Again, we shouldn't reschedule TX work in an else clause because the
+	 * system is suspended and the interrupt handler will be called when it
+	 * is resumed
+	 */
 }
 
 int wl12xx_sdio_request_irq(struct device *child,
@@ -255,7 +279,7 @@ int wl12xx_sdio_request_irq(struct device *child,
 	glue->handler = handler;
 	glue->thread_fn = thread_fn;
 	glue->irq_cookie = cookie;
-	ret = sdio_claim_irq(func, wl12xx_sdio_interrupt);
+	ret = sdio_claim_irq_lockless(func, wl12xx_sdio_interrupt);
 	sdio_release_host(func);
 	printk("claiming sdio irq (func=%d). ret=%d\n", func->num, ret);
 	return ret;
diff --git a/drivers/net/wireless/ti/wlcore/wlcore.h b/drivers/net/wireless/ti/wlcore/wlcore.h
index 67232ad..b8841cc 100644
--- a/drivers/net/wireless/ti/wlcore/wlcore.h
+++ b/drivers/net/wireless/ti/wlcore/wlcore.h
@@ -477,6 +477,7 @@ int wlcore_set_key(struct wl1271 *wl, enum set_key_cmd cmd,
 void wlcore_regdomain_config(struct wl1271 *wl);
 irqreturn_t wl12xx_hardirq(int irq, void *cookie);
 irqreturn_t wlcore_irq(int irq, void *cookie);
+int wlcore_irq_locked(struct wl1271 *wl);
 
 static inline void
 wlcore_set_ht_cap(struct wl1271 *wl, enum ieee80211_band band,
-- 
1.7.9

